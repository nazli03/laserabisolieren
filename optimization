import numpy as np
from scipy.optimize import differential_evolution, NonlinearConstraint
import pandas as pd

# Konstante Laserparameter
d = 0.02  # mm (Spotdurchmesser)
laser_power = 300  # W (Laserleistung)
area = np.pi * (d / 2)**2

# Zielfunktion mit gewichteten Belohnungstermen
def objective(x, alpha=2.0, beta=2.0, gamma=0.5):
    n_vr, n_hr, n_nr, f_vr, f_hr, f_nr, s_vr, s_hr, s_nr, a_vr, a_hr, a_nr = x

    # Regressionsformel des durchschnittlichen RFU-Werts
    rfu = (
        2.2133 - 0.4086 * n_vr + 0.1753 * n_hr + 0.2573 * n_nr +
        (-8.9240 + 0.0627 * f_vr - 0.0023 * f_hr + 0.008 * f_nr) +
        (-1.3036 - 0.0062 * a_vr + 0.0357 * a_hr - 0.0106 * a_nr) +
        (-0.7049 + 0.0004 * s_vr) +
        (0.27 + 0.02 * d * 1000) +
        (0.0218 * 100 - 0.0144 * 100)
    )

    # Belohnungsterme jeweils für VR
    PO = 1 - (a_vr / (f_vr * d))
    SO = 1 - (s_vr / (f_vr * d))
    F = (laser_power / f_vr) / area

    return rfu - alpha * PO - beta * SO - gamma * F

# Nebenbedingungen für PO, SO, Fluenz für alle drei Reinigungsphasen
def constraint_PO(x): return 1 - (x[9] / (x[3] * d)) - 0.4

def constraint_SO(x): return 1 - (x[6] / (x[3] * d)) - 0.4

def constraint_PO_hr(x): return 1 - (x[10] / (x[4] * d)) - 0.4

def constraint_SO_hr(x): return 1 - (x[7] / (x[4] * d)) - 0.4

def constraint_PO_nr(x): return 1 - (x[11] / (x[5] * d)) - 0.4

def constraint_SO_nr(x): return 1 - (x[8] / (x[5] * d)) - 0.4

def constraint_fluence_vr(x): return (laser_power / x[3]) / area - 3.0

def constraint_fluence_hr(x): return (laser_power / x[4]) / area - 3.0

def constraint_fluence_nr(x): return (laser_power / x[5]) / area - 3.0

# Nebenbedingungsliste 
constraints = [
    NonlinearConstraint(constraint_fluence_vr, 0, np.inf),
    NonlinearConstraint(constraint_fluence_hr, 0, np.inf),
    NonlinearConstraint(constraint_fluence_nr, 0, np.inf),
    NonlinearConstraint(constraint_PO, 0, np.inf),
    NonlinearConstraint(constraint_SO, 0, np.inf),
    NonlinearConstraint(constraint_PO_hr, 0, np.inf),
    NonlinearConstraint(constraint_SO_hr, 0, np.inf),
    NonlinearConstraint(constraint_PO_nr, 0, np.inf),
    NonlinearConstraint(constraint_SO_nr, 0, np.inf),
]

# Grenzen für Variablen
bounds = [
    (1, 10),     # n_vr
    (1, 10),     # n_hr
    (1, 10),     # n_nr
    (167, 20000),# f_vr
    (167, 20000),# f_hr
    (167, 20000),# f_nr
    (50, 3000),  # s_vr
    (50, 3000),  # s_hr
    (50, 3000),  # s_nr
    (1, 3000),   # a_vr
    (1, 3000),   # a_hr
    (1, 3000)    # a_nr
]

# Optimierung starten
result = differential_evolution(
    func=lambda x: objective(x, alpha=2.0, beta=2.0, gamma=2.0),
    bounds=bounds,
    constraints=constraints,
    strategy="best1bin",
    maxiter=300,
    popsize=15,
    tol=1e-6,
    seed=42
)

# Ergebnis anzeigen
x = result.x
parameter_table = pd.DataFrame({
    "Parameter": [
        "n_vr", "n_hr", "n_nr",
        "f_vr (Hz)", "f_hr (Hz)", "f_nr (Hz)",
        "s_vr (mm/s)", "s_hr (mm/s)", "s_nr (mm/s)",
        "a_vr (mm/s)", "a_hr (mm/s)", "a_nr (mm/s)"
    ],
    "Wert": x.round(2)
})
print("\nOptimale Parameterkombination:")
print(parameter_table.to_string(index=False))

# Zusätzliche Kennwerte berechnen
def calc_metrics(f, s, a):
    PO = 1 - (a / (f * d))
    SO = 1 - (s / (f * d))
    F = (laser_power / f) / area
    return PO, SO, F

PO_vr, SO_vr, F_vr = calc_metrics(x[3], x[6], x[9])
PO_hr, SO_hr, F_hr = calc_metrics(x[4], x[7], x[10])
PO_nr, SO_nr, F_nr = calc_metrics(x[5], x[8], x[11])

def compute_rfu(x):
    n_vr, n_hr, n_nr, f_vr, f_hr, f_nr, s_vr, s_hr, s_nr, a_vr, a_hr, a_nr = x
    return (
        2.2133 - 0.4086 * n_vr + 0.1753 * n_hr + 0.2573 * n_nr +
        (-8.9240 + 0.0627 * f_vr - 0.0023 * f_hr + 0.008 * f_nr) +
        (-1.3036 - 0.0062 * a_vr + 0.0357 * a_hr - 0.0106 * a_nr) +
        (-0.7049 + 0.0004 * s_vr) +
        (0.27 + 0.02 * d * 1000) +
        (0.0218 * 100 - 0.0144 * 100)
    )

rfu_value = compute_rfu(x)
print(f"\nRegressionsbasierter (echter) RFU-Wert: {rfu_value:.2f}")

print("\nPhysikalische Kennwerte pro Reinigungsphase:")
print(f"VR  → PO: {PO_vr*100:.2f}%, SO: {SO_vr*100:.2f}%, Fluenz: {F_vr:.2f} J/mm²")
print(f"HR  → PO: {PO_hr*100:.2f}%, SO: {SO_hr*100:.2f}%, Fluenz: {F_hr:.2f} J/mm²")
print(f"NR  → PO: {PO_nr*100:.2f}%, SO: {SO_nr*100:.2f}%, Fluenz: {F_nr:.2f} J/mm²")
print(f"\nQualitätsbewerteter RFU-Wert: {result.fun:.2f}")
